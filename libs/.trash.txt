-- SO THIS IS WHERE TRASH UNSUED CODE GOES
--PEPITAS :
--RATHER THAN ADJUSTING THE ANGLES
--HOW ABOUT I ADJUST SCREEN POSITIONNING
--SO WHEN ITS LIKE OVER 360 * width /FOV = large_sreen_width
-- IT IS RATHER just over 0
-- for both coordinates
-- See ya

--BIG PROBLEM : HOW TO KNOW WETHER YOU DRAW WALLS OR ENTITIES ?
-- CREATE A TO DRAW TABLE SORTED? WiTH AN IF THAT GETS THE BODY TYPE

--MULTPLAYER.LUA








--OLD FUNCTION USED WITH THREADS
-- function Multiplayer.StartServer(Game)
--     local GameChannel = love.thread.getChannel("GameServerThread") --this is the channel that the thread will use to communicate with the main thread
--     local InputCommuncicationChannel = love.thread.getChannel("InputServerThread")
--     local OutputCommuncicationChannel = love.thread.getChannel("OutputServerThread")
--     local enet = require("enet")
--     local host = enet.host_create("localhost:6789")
--     print("host created")
--     --setup a thread which does things right when somebody tries to connect ?
--     while Game.IsPublic do
--         Game = GameChannel:demand(0.0001) or Game
--         local event = host:service(100)
--         if event then
--             if event.type == "connect" then
--                 print("A client connected from", event.peer)
--                 OutputCommuncicationChannel:push("Connected")
--                 event.peer:send(InputCommuncicationChannel:demand())
--             elseif event.type == "receive" then
--                 print("Got message: ", event.data, "from", event.peer)
--                 event.peer:send("world")
--             else
--                 print(event.type, event.peer, event.data)
--             end
--         -- else
--         --     print(Game.IsPublic)
--         end
--     end
--     host:destroy()
--     print("Server stopped")
-- end
-- function Multiplayer.ServerReceive (players, Channels, Player, players)
--     local event = Channels.OutputCommuncicationChannel:pop()
--     if event then
--         if event == "Connected" then
--             print("New player connected!")
--             players.list[#players.list + 1] = Player.createPlayer(#players.list + 1, world)
--             print("Sending player number", players.list[#players.list].number)                    --Somehow it sends the wrong number
--             Channels.InputCommuncicationChannel:push(players.list[#players.list].number)
--         elseif event == "Update" then
--             print("Loaded!")
--             Game.IsLoading = false
--             Game.InClientGame = true
--         end
--     end
-- end




-- function Multiplayer.Thread(ipaddr, Game, GameStatePointer)
--     local enet = require("enet")
--     local json = require("libs.external.lunajson")
--     local ffi = require("ffi")    
--     local FFIUtils = require("libs.FFIutils")
--     local gameState = ffi.cast("GameState*", ffi.cast("uintptr_t", GameStatePointer))
--     local Entities = gameState.entities
--     local Walls = gameState.walls




--     print("Connecting to", ipaddr)
--     local host = enet.host_create()
--     GameChannel = love.thread.getChannel("MultplayerThread") --this is the channel that the thread will use to communicate with the main thread
--     -- host:channel_limit(3)
--     local server = host:connect(ipaddr, 3)  --3 is the number of channels. add more if needed
--     -- Channel:push(server)
--     while not Game.IsConnectedToHost do
--         local event = host:service(1000)
--         if event then
--             print("got event")
--             if event.type == "connect" then
--                 print("Successfully connected to", ipaddr)
--                 Game.IsConnectedToHost = true
--                 GameChannel:push("Connected")
--             else
--                 print (event.type, event.peer, event.data)
--             end
--         end
--     end
--     while Game.IsLoading do
--         local event = host:service(100)
--         if event then
--             if event.type == "receive" then
--                 if event.channel == Game.enetChannels.NumberChannel then
--                     print("We are player number", event.data)
--                     -- LocalPlayer.number = event.data --actually might be sent every frame? ACTUALLY NO BC I SEND TO ALL PEERS
--                     Game.IsLoading, Game.InClientGame = false, true
--                     GameChannel:push("Loaded")
--                 else
--                     print("error wtf")
--                 end
--             end
--         end
--     end
--     print("Game started")
--     --Handle communications?
--     while Game.InClientGame do
--         local event = host:service()
--         if event then
--             if event.type == "receive" then
--                 if event.channel == Game.enetChannels.EntityChannel then
--                     -- print("Received from server (entities):", event.data)
--                     local data = json.decode(event.data)
--                     for i, obj in ipairs(data) do
--                         print("Received object:", obj.type, "at", obj.x, obj.y)
--                     --     Entities[i].pos.x = obj.x
--                     --     Entities[i-1].pos.y = obj.y
--                     --     Entities[i-1].type = (obj.type == "Bullet") and 1 or 2
--                     --     Entities[i-1].angle = obj.angle or 0
--                     --     Entities[i-1].number = obj.number or 0
--                     end      -- PROBLEMS
--                 elseif event.channel == Game.enetChannels.WallsChannel then
--                 else
--                 print("Got message: ", event.data, "from", event.peer, "on channel", event.channel)
--                 end
--             else
--                 print(event.type, event.peer, event.data)
--             end
--         -- else
--         --     print("No event")
--         end
--         -- server:send("hi", 0)
--         -- host:flush()
--     end
-- end


function Multiplayer.ServerReceive (dt, players, Channels, Player, Game, Entities)
    -- for index, player in ipairs(players.list) do
    --     if player.peer ~= "local" then
    --         local event = player.peer:receive()
    --         if event then
    --             print("Got message: ", event.data, "from", event.peer , "on channel", event.channel)
    --             if event.type == "receive" then
    --                 event.peer:send("world")
    --             else
    --                 print(event.type, event.peer, event.data)
    --             end
    --         end
    --     end
    -- end
end
















--MAIN.LUA

--LoaD


    -- Channels.InputCommuncicationChannel = love.thread.getChannel("InputServerThread")
    -- Channels.OutputCommuncicationChannel = love.thread.getChannel("OutputServerThread")
    -- Channels.GameChannel = love.thread.getChannel("GameServerThread")


-- function JoinGame()
--     local ThreadScrpit = string.dump(Multiplayer.Thread)
--     local MultplayerThread = love.thread.newThread(ThreadScrpit)
--     MultplayerThread:start()
--     Multiplayer.ThreadChannel = love.thread.getChannel("MultplayerThread")
-- end

--INGAME.LUA

updatewhileloading
    -- local message = channel:pop()
    --     if message then
    --         if message == "Connected" then
    --             print("Connected to host!")
    --             Game.IsConnectedToHost = true
    --         elseif message == "Loaded" then
    --             print("Loaded!")
    --             Game.IsLoading = false
    --             Game.InClientGame = true
    --         end
    --     end
        -- print("Game.IsJoining: ", Game.IsJoining)


updatehost
    do
        local coucou = ""
        if Game.InHostedGame then 
            local     x1, y1 = player.body:getPosition()
            local     x2, y2 =  x1 + math.cos(player.angle) * 4000, y1 + math.sin(player.angle) * 3000
            -- x2, y2 = 1,1
                -- world:rayCast(x1, y1, x2, y2,
                -- -- world:rayCast(x2, y2, x1, y1,
                --     function(fixture, hitX, hitY, normalX, normalY, fraction)
                --         coucou ="Hit fixture with userdata:" .. fixture:getUserData() .. "    " ..  fraction  .. "\n"
                --         player.Highlight = fixture:getUserData()
                --         -- print("Hit fixture with userdata: " .. fixture:getUserData() .. " at fraction: " .. fraction)
                --         return 0 -- Stop at the first hit
                --     end
                -- )
        else
            coucou = "Not in hosted game"
        end
        -- Game.Debug = player.weapon.name .. "\n \n" .. coucou .. math.deg(player.pitch)
    end


DRAW.LUA

    drawing textured walls, alternative vertices
    
                    { vertices[1], vertices[2], 0, 0 },
                    { vertices[3], vertices[4], 0, 1 },
                    { vertices[5], vertices[6], 1, 1 },
                    { vertices[7], vertices[8], 1, 0 }
    ancienne façon de calculer la position à l'a'écran des personnages adverses
                -- y = 500 * math.exp(-dist) + screen_height / 2 

    HUD effect for weaponshearing
    -- x = (LocalPlayer.isZooming and -1 or 1) * (LocalPlayer.fov - math.pi/2) * (LocalPlayer.fov - math.pi/3),


    Quand on triait que des murs
    function SortWalls(walls, player)
    -- table.sort(walls, function(a, b)
    -- local dist_a = {
    --     s = math.sqrt((a[1][1] - player.x)^2 + (a[1][2] - player.y)^2),
    --     e = math.sqrt((a[2][1] - player.x)^2 + (a[2][2] - player.y)^2)
    -- }
    -- local dist_b = {
    --     s = math.sqrt((b[1][1] - player.x)^2 + (b[1][2] - player.y)^2),
    --     e = math.sqrt((b[2][1] - player.x)^2 + (b[2][2] - player.y)^2)
    -- }
    -- local min_dist_a = math.min(dist_a.s, dist_a.e)
    -- local min_dist_b = math.min(dist_b.s, dist_b.e)

    -- return min_dist_a > min_dist_b
    -- end)


    --Sorting the walls
    table.sort(walls, function(a, b)
        -- Calculate the midpoint of wall 'a'
        local mid_a_x = (a.pos[1][1] + a.pos[2][1]) / 2
        local mid_a_y = (a.pos[1][2] + a.pos[2][2]) / 2

        -- Calculate the distance from player to the midpoint of wall 'a'
        local dist_a = math.sqrt((mid_a_x - player.x)^2 + (mid_a_y - player.y)^2)

        -- Calculate the midpoint of wall 'b'
        local mid_b_x = (b.pos[1][1] + b.pos[2][1]) / 2
        local mid_b_y = (b.pos[1][2] + b.pos[2][2]) / 2

        -- Calculate the distance from player to the midpoint of wall 'b'
        local dist_b = math.sqrt((mid_b_x - player.x)^2 + (mid_b_y - player.y)^2)

        -- Compare the distances
        return dist_a > dist_b
    end)

    return walls
end

BUTTONSLUA

                -- love.thread.newThread(string.dump(Multiplayer.StartServer)):start(Game)
                --ABOVE LINE IF ANY LAG IS CAUSED WITHOUT THE THREAD